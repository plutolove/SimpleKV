## Rust宏笔记
Rust宏详细内容在[宏小册](http://blog.luxko.site/tlborm-chinese/book/mbe-min-captures-and-expansion-redux.html)，以下只记录使用语法
### 宏捕获  
宏模式中还可以包含捕获。这允许输入匹配在某种通用语法基础上进行，并使得结果被捕获进某个变量中。此变量可在输出中被替换使用。

捕获由`$`符号紧跟一个标识符`(identifier)`紧跟一个冒号`(:)`紧跟捕获种类组成。捕获种类须是如下之一：

`item`: 条目，比如函数、结构体、模组等。
`block`: 区块(即由花括号包起的一些语句加上/或是一项表达式)。
`stmt`: 语句
`pat`: 模式
`expr`: 表达式
`ty`: 类型
`ident`: 标识符
`path`: 路径 `(例如 foo, ::std::mem::replace, transmute::<_, int>, …)`
`meta`: 元条目，即被包含在 `#[...]`及`#![...]`属性内的东西。
`tt`: 标记树
举例来说，下列宏将其输入捕获为一个表达式：
```rust
macro_rules! one_expression {
    ($e:expr) => {...};
}
```
Rust编译器的语法转义器将保证捕获的“准确性”。一个`expr`捕获总是会捕获到一个对当前`Rust`版本来说完整、有效的表达式。

你可以将字面标记树与捕获混合使用，但有些限制(接下来将阐明它们)。

在扩展过程中，对于某捕获`$name:kind`，我们可以通过在`expansion`中写下`$name`来使用它。比如：
```rust
macro_rules! times_five {
    ($e:expr) => {5 * $e};
}
```
如同宏扩展本身一样，每一处捕获也都将被替换为一个完整的`AST`节点。也就是说，在上例中无论$e所捕获的是怎样的标记序列，它总会被解读成一个完整的表达式。

在一条模式中也可以出现多次捕获：
```rust
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
}
```
### 重复
模式中可以包含重复。这使得匹配标记序列成为可能。重复的一般形式为`$ ( ... ) sep rep`.

`$` 是字面标记。
`( ... )` 代表了将要被重复匹配的模式，由小括号包围。
`sep`是一个可选的分隔标记。常用例子包括,和;。
`rep`是重复控制标记。当前有两种选择，分别是* (代表接受0或多次重复)以及+ (代表1或多次重复)。目前没有办法指定“0或1”或者任何其它更加具体的重复计数或区间。
重复中可以包含任意有效模式，包括字面标记树，捕获，以及其它的重复。

在扩展部分，重复也采用相同的语法。

举例来说，下述宏将每一个`element`都通过`format!`转换成字符串。它将匹配0或多个由逗号分隔的表达式，并分别将它们展开成一个`Vec`的`push`语句。
```rust
macro_rules! vec_strs {
    (
        // 重复开始：
        $(
            // 每次重复必须有一个表达式...
            $element:expr
        )
        // ...重复之间由“,”分隔...
        ,
        // ...总共重复0或多次.
        *
    ) => {
        // 为了能包含多条语句，
        // 我们将扩展部分包裹在花括号中...
        {
            let mut v = Vec::new();

            // 重复开始：
            $(
                // 每次重复将包含如下元素，其中
                // “$element”将被替换成其相应的展开...
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}
```